<!DOCTYPE html>
<style type='text/css'>
    rect.bar {
        fill: #ccf;
        stroke: #000;
    }
</style>
<script src="https://d3js.org/d3.v4.min.js"></script>
<div id='root'></div>
<div id='rootC'></div>
<!--button>run renderBars</button-->

<script>
    var root = d3.select('#root');
    var rootC = d3.select('#rootC');
    var w = 1000;
    var h = 200;
    var svg = root.append('svg')
        .style('display', 'block')
        .attr('width', w)
        .attr('height', h);
    var svgC = rootC.append('svg')
        .style('display', 'block')
        .attr('width', w)
        .attr('height', h);
    /* We will draw 3-5 bars for random numbers in the range [0, 1), with a small text label afterwards. 30 is, sadly,
    a magic number - you can expect a few of these in svg. */
    var xScale = d3.scaleLinear().range([0, w]);  // Allow 30 pixels of space for the labels.
    var yScale = d3.scaleLinear()
    /* Note the domain is constant; this way, the size of a bar is constant whether we have 3, 4, or 5. */
        .domain([0, 5])
        .range([0, h]);

    var currentBarIndex = 0;
    var data = [1,1,1,1,1 ];    // between [0, 1)
    var dataLabel = ["John", "Mary", "Peter", "Thomas", "JÃ¼rgen"];    // between [0, 1)

    var nextBar = function () {
        if (currentBarIndex < 5) {
            currentBarIndex++;
        } else {
            currentBarIndex = 0;
        }
        data.forEach(chooseNextBar);
        renderBars();
    }

    function chooseNextBar(element, index, array) {
        if (currentBarIndex == index) {
            array[index] = 1;
        } else {
            array[index] = .9;
        }
    }

    var renderBars = function() {
        /* enter of the enter-update-exit triumvirate. Keep in mind this selection will have initial attrs we specify here,
         as well as potentially updated attrs specified later on the root selection's transition. If an attr never changes -
          like the class of a bar - set it on newly created enter nodes. */
        var bars = svg.selectAll('rect.bar').data(data);
        bars.enter().append('rect')
            .attr('class', 'bar')
            /* The enter animation is a fade in from 0 opacity combined with a grow to the target width.Using xScale(0)
             for the x position makes our code more flexible. If we changed the bars to have an indent of 10px, this code
              need not change.The same effect could, of course, be accomplished using a <g> element and modifying its
              transform property. */
            .attr('opacity', 0)
            .attr('x', xScale(0))
            /* Each bar should get some padding. I arbitrarily decided 20% the height of a bar between each bar - or,
            10% from the top and 10% from the bottom.Or, in other words, each bar should go from yScale(i + 0.1) to
            yScale(i + 0.9). The height could also be written as, simply, yScale(0.8) or with constants. It comes down
             to taste, though I chose this value to call out the duality of the y and height properties. As with the
              xScale(0) call above, make sure whichever solution you think looks best uses the yScale. */
            .attr('y', function(d, i) { return yScale(i + 0.1); })
            .attr('height', function(d, i) { return yScale(i + 0.9) - yScale(i + 0.1);});
        bars.transition()
        /* update of the enter-update-exit triumvirate. One gotcha with the pattern is the behavior of repeated calls
         to transition on a node - the last one wins.Even if it looks cleaner to handle the transition from 0 opacity
         to 1 on the new nodes using the newBars selection, the subsequent transition on bars would override it. Sometimes, an enter animation is distinct enough from the update that separating the two makes sense - in this case, either set up your update transition before appending new nodes, or place the enter transition after the update transition. */
            .attr('width', xScale)
            .attr('opacity', 1);
        bars.exit().transition()
        /* exit of the enter-update-exit triumvirate. We are initiating a transition, so the remove call won't happen
         until the animation has ended. */
            .attr('opacity', 0)
            .attr('width', 0)
            .remove();

        var labels = svg.selectAll('text.label').data(dataLabel);
        labels.enter().append('text')
            .attr('class', 'label')
            // We go through the same opacity hoops as on the bars with our text. In fact, much of the animation is the same so that text and bars appear a single unit.
            .attr('opacity', 0)
            //.attr('x', xScale(0))
            .attr('x', 0)
            .attr('y', function(d, i) { return yScale(i + 0.5); })
            // 0.3em is a magic number that looks good, giving just enough padding. Pixels would be a fine measure as well - five of them or so.
            .attr('dx', '0.3em')
            // 0.35em is SVG for vertical-align: center - not technically true, but true enough.
            .attr('dy', '0.35em');
        labels.transition()
            //.attr('x', xScale)
            .attr('x', 10)
            .attr('opacity', 1)
            // The d3.format mini-language is very rich and familiar to users of Python, and ever-so-slightly confusing to those accustomed to printf. You can just yell at me to get off your lawn, really.
            .text(function(d) { return d; });
        labels.exit().transition()
            .attr('opacity', 0)
            //.attr('x', xScale(0))
            .attr('x', 0)
            .remove();

    };

    var currentIndex = 0;
    var dataC = [1,1,1,1,1];    // between [0, 1)

    var nextItem = function () {
        if (currentIndex < 5) {
            currentIndex++;
        } else {
            currentIndex = 0;
        }
        dataC.forEach(chooseNext);
        renderCircles();
    }

    function chooseNext(element, index, array) {
        if (currentIndex == index) {
            array[index] = 1000;
        } else {
            array[index] = 1;
        }
    }

    var renderCircles = function() {

        //var circle = d3.selectAll("circle");
        //Make an SVG Container
        var circles = svgC.selectAll("circle").data(dataC);
        circles.enter().append("circle")
            .attr("cy", 60)
            .attr("cx", function(d, i) { return i * 100 + 30; })
            .attr('r', 0)
        circles.transition()
            .attr("r", function(d) { return Math.sqrt(d); });
        circles.exit().transition()
            .attr('r', 0)
            .remove();
        /*circles.transition()
            .attr('width', xScale)
            .attr('opacity', 1);
        circles.exit().transition()
            .attr('opacity', 0)
            .attr('width', 0)
            .remove();
*/
        /*
        var numData = 3 + Math.floor(Math.random() * 3);  // 3-5 numbers
        var data = d3.range(numData).map(Math.random);    // between [0, 1)
        /* enter of the enter-update-exit triumvirate. Keep in mind this selection will have initial attrs we specify here,
         as well as potentially updated attrs specified later on the root selection's transition. If an attr never changes -
         like the class of a bar - set it on newly created enter nodes.
        var node = svg.selectAll('.node').data(data).leaves();
        var newBars = node.enter().append('g')
            .attr('class', 'node')
            /* The enter animation is a fade in from 0 opacity combined with a grow to the target width.Using xScale(0)
             for the x position makes our code more flexible. If we changed the bars to have an indent of 10px, this code
             need not change.The same effect could, of course, be accomplished using a <g> element and modifying its
             transform property.
            .attr('opacity', 0)
            .attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; });

            //.attr('x', xScale(0))
            /* Each bar should get some padding. I arbitrarily decided 20% the height of a bar between each bar - or,
             10% from the top and 10% from the bottom.Or, in other words, each bar should go from yScale(i + 0.1) to
             yScale(i + 0.9). The height could also be written as, simply, yScale(0.8) or with constants. It comes down
             to taste, though I chose this value to call out the duality of the y and height properties. As with the
             xScale(0) call above, make sure whichever solution you think looks best uses the yScale.
            //.attr('y', function(d, i) { return yScale(i + 0.1); })
            //.attr('height', function(d, i) { return yScale(i + 0.9) - yScale(i + 0.1);});
        node.transition()
        /* update of the enter-update-exit triumvirate. One gotcha with the pattern is the behavior of repeated calls
         to transition on a node - the last one wins.Even if it looks cleaner to handle the transition from 0 opacity
         to 1 on the new nodes using the newBars selection, the subsequent transition on bars would override it. Sometimes, an enter animation is distinct enough from the update that separating the two makes sense - in this case, either set up your update transition before appending new nodes, or place the enter transition after the update transition.
            .attr('width', xScale)
            .attr('opacity', 1);
        node.exit().transition()
        /* exit of the enter-update-exit triumvirate. We are initiating a transition, so the remove call won't happen
         until the animation has ended.
            .attr('opacity', 0)
            .attr('width', 0)
            .remove();
*/
        /*var labels = svg.selectAll('text.label').data(data);
        var newLabels = labels.enter().append('text')
            .attr('class', 'label')
        */    /* We go through the same opacity hoops as on the bars with our text. In fact, much of the animation is the same so that text and bars appear a single unit. */
        /*    .attr('opacity', 0)
            .attr('x', xScale(0))
            .attr('y', function(d, i) { return yScale(i + 0.5); })
            // 0.3em is a magic number that looks good, giving just enough padding. Pixels would be a fine measure as well - five of them or so.
            .attr('dx', '0.3em')
            // 0.35em is SVG for vertical-align: center - not technically true, but true enough.
            .attr('dy', '0.35em');
        labels.transition()
            .attr('x', xScale)
            .attr('opacity', 1)
            // The d3.format mini-language is very rich and familiar to users of Python, and ever-so-slightly confusing to those accustomed to printf. You can just yell at me to get off your lawn, really.
            .text(d3.format('.2f'));
        labels.exit().transition()
            .attr('opacity', 0)
            .attr('x', xScale(0))
            .remove();
            */
    };

    root.append('button')
        .text('NextBar')
        .on('click', nextBar);
    root.append('button')
        .text('NextItem')
        .on('click', nextItem);
</script>